#!/usr/bin/perl
use v5.16; use warnings; use strict;
use FindBin qw($Bin $RealBin $RealScript); use lib "$Bin/../lib";
use Data::Dumper; #For debugging


### Settings according to the example in README.md ###
#( You don't want use these but you can leave them here for documentational purposes, they are overwritten in the next step)
my $server = {
	user	=> "someuser",
	host	=> "1.2.3.4",
	card	=> "eths",
	sshport	=> 22789,
	dns	=> [ "5.6.7.8", "9.10.11.12" ]
};
my $client = {
	card	=> "ethc",
	gateway	=> "13.14.0.254",
	subnets	=> [ "13.14.0.0/16", "15.16.17.0/24" ],
	dns	=> [ "15.16.17.1", "15.16.17.2"]
};


### Default settings ###
$server = {}; $client = {};	#cleanup example settings
$server->{sshport} = 22;	#default ssh port
$server->{dns} = [ "8.8.4.4", "8.8.8.8" ];	#google dnsservers, if the isp of the server blocks these, use the ones of your isp

#default settings of other things
my $onserver = undef;	#defined when running on the server
my $checkssh = undef;	#defined if we are checking ssh the server
my $debuglevel = 0;
my $originaluser = undef;


### Main part of the program
runasroot();
parseargs();
my ($ssh, $screen, $socat, $iptables, $systemctl, $journalctl, $route); findprograms();
examinesystem();
showsettings();
if(defined $checkssh) { checksshserver(); }	#Restarts the sshserver if it's not running, shows some connection possibilities and quits the program
if(defined $onserver) {
	servercode();
	debug(1, "Server finished");
} else {
	clientcode();
	debug(1, "Client finished");
}
if($debuglevel > 3) { error("$debuglevel Quiting as requested because of high debuglevel..."); }


### Subroutine definitions

#Everything the code does when running as a server
sub servercode {
	#TODO
}

#Everything the code does when running as a client
sub clientcode {
	#TODO
}

#Complete info in $client and $server by examining the settings
sub examinesystem {
	if(defined $onserver) {
	} else {
		if(not defined $server->{user}) {
			if(defined $originaluser) {
				$server->{user} = $originaluser;
			} else {
				my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid(0);
				$server->{user} = $name;
			}
		}
	}
}

#Find locations of all needed programs
sub findprograms {
	$ssh = searchlocation("ssh"); unless(defined $ssh) { error("'ssh' is not installed, on debian-based systems you can install it with 'apt-get install ssh'"); }
	$screen = searchlocation("screen"); unless(defined $screen) { error("'screen' is not installed, on debian-based systems you can install it with 'apt-get install screen'"); }
	$socat = searchlocation("socat"); unless(defined $socat) { error("'socat' is not installed, on debian-based systems you can install it with 'apt-get install socat'"); }
	if(defined $onserver) {
		$iptables = searchlocation("iptables"); unless(defined $iptables) { error("'iptables' is not installed, on debian-based systems you can install it with 'apt-get install iptables'"); }
		$systemctl = searchlocation("systemctl"); unless(defined $systemctl) { error("systemd is not installed, on debian-based systems you can install it with 'apt-get install systemd'."); }
		$journalctl = searchlocation("journalctl");
	} else {
		$route = searchlocation("route"); unless(defined $route) { error("'route' is not installed, on debian-based systems you can install it with 'apt-get install net-tools'"); }
	}
}

#Check if necessary args are given and use them to change the settings
sub parseargs {
	if($#ARGV == -1) { error("No arguments given. When running on the server you need (at least) --server-checkssh or --server. When running on the client you need (at least) the server to connect to"); }
	while($#ARGV>=0) {
		$_ = shift @ARGV;
		if(/^-p$/i or /^--port$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^\d+$/ or $ARGV[0] == 0 or $ARGV[0] > 65535) { error("No valid portnumber has been given to '-p' or '--port'"); }
			$server->{sshport} = shift @ARGV;
		}
		elsif(/^-d$/i or /^--server-dns$/i or /^--client-dns$/) {	#-d is short for--server-dns, -D is short for client-dns
			if($#ARGV < 0) { error("No DNS-servers given to one of the dns-server options"); }
			my $dnsservers = shift @ARGV;
			unless($dnsservers =~ /^[\d\.,]+$/) { error("Incorrect format for the DNS-servers, provide them as IP's seperated by commas. Example: 8.8.4.4,8.8.8.8"); }
			my @dnsservers = split(/,/, $dnsservers);
			if($_ eq "-d" or /^--server-dns$/) { $server->{dns} = \@dnsservers; } else { $client->{dns} = \@dnsservers; }
		}
		elsif(/^-c$/i or /^--server-card$/i or /^--client-card$/) {	#-c is short for--server-card, -C is short for client-card
			if($#ARGV < 0) { error("No networkcard given to one of the networkcard options"); }
			my $card = shift @ARGV;
			unless($card =~ /^\w+$/) { error("No valid networkcard has been given"); }
			if($_ eq "-c" or /^--server-card$/) { $server->{card} = $card } else { $client->{card} = $card }
		}
		elsif(/^-g$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^[\d\.]+$/) { error("No gateway has been given"); }
			$client->{gateway} = shift @ARGV;
		}
		elsif(/^-o$/i or /^--original-user$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^\w+$/) { error("The original username has not been given"); }
			$originaluser = shift @ARGV;
		}
		elsif(/^-n$/i or /^--subnets$/i) {
			if($#ARGV < 0) { error("No subnets given"); }
			my $subnets = shift @ARGV;
			unless($subnets =~ /^[\d\.\/,]+$/) { error("Incorrect format for the subnets, provide them as subnets seperated by commas. Example: 13.14.0.0/16,15.16.17.0/24"); }
			my @subnets = split(/,/, $subnets);
			$client->{subnets} = \@subnets;
		}
		elsif(/^-v$/i or /^--verbose$/) { $debuglevel++; }
		elsif(/^--server$/i) { $onserver = 1; }	#the presence of the '--server' option determines if we are running on the server or on the client system
		elsif(/^--server-checkssh$/i) { $onserver = 1; $checkssh = 1; }	#the presence of the '--server-checkssh' option determines if we are still setting up the server locally
		elsif($#ARGV == -1 and not defined $onserver) {
			if(/(.+)@(.+)/) { $server->{user} = $1; $server->{host} = $2; } else { $server->{host} = $_; }
		}
		else { error("'$_' is not a valid option"); }
	}
}

sub showsettings {
	if(defined $onserver) { debug(3, "Running as server"); } else { debug(3, "Running as client"); }
	if(defined $checkssh) { debug(3, "Running a sshcheck"); }
	debug(3, "Debuglevel: $debuglevel");
	debug(3, "server: " . Dumper($server));
	debug(3, "client: " . Dumper($client));
}

#exec() with debugmessage
sub debugexec {
	my $command = join(" ", @_);
	debug(2, "Now running '$command'. I won't return when this is finished.");
	exec(@_);
}

#system() with debugmessage
sub debugsystem {
	my $command = join(" ", @_);
	debug(2, "Now starting child '$command', i won't be using the output. I'll tell you the returncode when it's finished.");
	my $returncode = system(@_);
	debug(1, "'$command' was started and it finished with returncode '$returncode'");
}

#Same as `` but with debugmessage
sub debugbackticks {
	my $command = shift;
	debug(2, "Now starting child '$command' and i will be using it's output. I'll tell you the returncode when it's finished.");
	my $commandoutput = `$command`;
	debug(1, "'$command' was started and it finished with returncode '$?'");
	if($debuglevel >= 3) {
		debug(3, "This was it's output:");
		debug(3, "--- BEGIN OUTPUT '$command' ---");
		foreach(split(/\n/, $commandoutput)) {
			debug(3, "$_");
		}
		debug(3, "--- END OUTPUT '$command' ---");
	}
	return $commandoutput;
}

#Restart the program as root if you are not root yet
sub runasroot {
	unless($< == 0) {
		foreach(@ARGV) { if(/^-v$/i or /^--verbose$/) { $debuglevel++; } }	#this sub runs before checking the args (or we lose them and can't pass them to sudo) so we have to check for a -v here... 
		debug(1, "You need to be root to run this script. I'll change the user for you.");	#... so that we can send a debugmessage if requested
		my $sudo = searchlocation("sudo");
		if(not defined $sudo) { error("'sudo' is not available. you'll have to find another way to become root and run this script."); }
		my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid($<);
		debugexec($sudo, "$RealBin/$RealScript", "-o", $name, @ARGV);
	}
}

#Prints errorstring passed as argument and exit with returncode 1
#If the string starts with a number, use this code instead and also mention the code in the output
sub error {
	my $error = shift;
	my $errorcode = 1; my $errorstring = $error;
	if($error=~/^(\d+)\s+(.*)/) { $errorcode = $1; $errorstring = $2 };
	print STDERR "error";
	unless($errorcode == 1) { print STDERR " (code $errorcode)"; }
	print STDERR ": $errorstring\n";
	exit $errorcode;
}

#use $PATH to find the location of a program passed as argument
sub searchlocation {
	my $program = shift;
	foreach(split /:/, $ENV{PATH} ) {
		my $test = "$_/$program";
		if(-f $test and -x $test) {
			debug(2, "'$program' found at '$test'");
			return $test;
		}
	}
	return undef;
}

#Restarts the ssh-server if it's not running, shows on which port it's running which users are you might login as and quits the program
sub checksshserver {
	my $running = undef; my $outputmessage = undef;
	foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check if ssh runs
	if(defined $running) {
		debug(2, "ssh-server is running correctly.");
	} else {
		debug(1, "ssh-server is not running (correctly). I'll restart it.");
		debugsystem($systemctl, "start", "ssh"); sleep 5;	#restart it when it's not running correctly (and give it 5 seconds to start)
		foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check it again
		if(defined $running) {
			debug(2, "ssh-server started correctly.");
		} else {
			error("I Can't start ssh correctly"); #die if it still fails
		}
	}
	foreach(split /\n/, debugbackticks("$journalctl -u ssh")) { if(/server\s+listening\s+on\s+\S+\s+port\s+(\d+)/i) { $outputmessage = "The sshserver is listening on tcp/$1"; } }	#check the port
	say "$outputmessage\nAvailable 'regular' users, make sure you can login as one of them:";
	open(my $fh, "/etc/passwd") or error("I can't read '/etc/passwd' this is needed to find available users.\nThe rest of the setup is done so if you know which username(s) you can use this isn't a problem");
	while(<$fh>) {
		/^(.+?):.+?:(\d+).*/; if($1 ne "nobody" and $2 >= 1000) { say "- $1"; }
	}
	close $fh;
	say "- root (will probably not work, most sshservers block root-logins)";
	exit;
}

#Show a debugmessage if the debuglevel is high enough for this message
sub debug {
	my ($level, $message) = @_;
	if($debuglevel >= $level) { say STDERR "DEBUG ($level): $message"; }
}
