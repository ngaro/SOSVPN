#!/usr/bin/perl
use v5.16; use warnings; use strict;
use FindBin qw($Bin $RealBin $RealScript); use lib "$Bin/../lib";

use Term::ReadKey;
use Data::Dumper; #For debugging

### Settings according to the example in README.md ###
#( You don't want use these but you can leave them here for documentational purposes, they are overwritten in the next step)
my $server = {
	user	=> "someuser",
	host	=> "1.2.3.4",
	card	=> "eths",
	sshport	=> 22789,
	dnsservers	=> [ "5.6.7.8", "9.10.11.12" ]
};
my $client = {
	card	=> "ethc",
	gateway	=> "13.14.0.254",
	subnets	=> [ "13.14.0.0/16", "15.16.17.0/24" ],
	dnsservers	=> [ "15.16.17.1", "15.16.17.2"],
	domains	=> [ "mylocal.net" ]
};

#Constants
my $clientportforward = 22002;
my $serverportforward = 22001;
my $clientsession = "sosvpnclient";
my $serverscriptlocation = "/tmp/sosvpn";
my $clientlogfile = "/tmp/logfile";

#Settings that can only be overwritten in code
my $system = "Unknown (unknown-user\@unknown-host)";


### Default settings ###
$server = {}; $client = {};	#cleanup example settings
$server->{sshport} = 22;	#default ssh port
$server->{dnsservers} = [ "8.8.4.4", "8.8.8.8" ];	#google dnsservers, if the isp of the server blocks these, use the ones of your isp

#default settings of other things
my $onserver = undef;	#defined when running on the server
my $checkssh = undef;	#defined if we are checking ssh the server
my $debuglevel = 0;
my $originaluser = undef;


### Main part of the program
my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid($<);
$system =~ s/unknown-user/$name/;
parseargs();
setsystemstring();
runasroot();
my ($ssh, $screen, $socat, $iptables, $systemctl, $journalctl, $route, $systemdresolve, $sudo, $scp); findprograms();
examinesystem();
showsettings();
if(defined $checkssh) { checksshserver(); }	#Restarts the sshserver if it's not running, shows some connection possibilities and quits the program
if(defined $onserver) {
	servercode();
	debug(1, "Server finished");
} else {
	clientcode();
	debug(1, "Client finished");
}
if($debuglevel > 3) { error("$debuglevel Quiting as requested because of high debuglevel..."); }


### Subroutine definitions

sub setsystemstring {
	if(defined $onserver) { $system =~ s/Unknown/Server/; } else { $system =~ s/Unknown/Client/; }
	my $hostname = searchlocation("hostname");
	if(defined $hostname) {
		my $thishost = debugbackticks($hostname, 0);
		chomp $thishost;
		$system =~ s/unknown-host/$thishost/;
	}
}

#Everything the code does when running as a server
sub servercode {
	debug(0,"TODO");
	exit;
}

#Run a screen in the background and control it for the clientcode
sub clientcode {
	debugsystem("$scp $RealBin/$RealScript $server->{user}\@$server->{host}:$serverscriptlocation");
	createscreen($clientsession);
	screencommand($clientsession, 0, "logfile $clientlogfile.0");
	screencommand($clientsession, 0, "log on");
	my $commandinssh = "$serverscriptlocation --server";
	if(defined $server->{card}) { $commandinssh .= " --server-card $server->{card}"; }
	for(my $i=0; $i < $debuglevel; $i++) { $commandinssh .= " -v"}
	inputtoscreen($clientsession, 0, "$sudo -u $originaluser $ssh -t -L $clientportforward:127.0.0.1:$serverportforward -p $server->{sshport} $server->{user}\@$server->{host} $commandinssh\n");
	my $pass = readpass($server->{user}, $server->{host});
	OUTERLOOP: while(1) {
		open(my $fh, "$clientlogfile.0");
		while(<$fh>) {
			if(/^\s*\[sudo\]/) { close $fh; last OUTERLOOP; }
		}
		close $fh;
	}
	inputtoscreen($clientsession, 0, "$pass\n", "password");
	if($debuglevel < 4) {
		screencommand($clientsession, 0, "log off");
		if($debuglevel < 3) { unlink("$clientlogfile.0"); }
	}
}

#return the pass read from STDIN for user arg1 on host arg2, do not show asterisks if arg3 is defined
sub readpass {
	my ($user, $host, $hidden) = @_;
	printf("Password for $user at $host: ");
	my $pass = "";
	ReadMode("raw");
	while(1) {
		my $key = ReadKey;
		if(ord($key) == 10) {
			print "\n";
			last;
		} elsif(ord($key) == 8 || ord($key) == 127) {
			if($pass eq "") { next; }
			chop($pass);
			unless(defined $hidden) { print "\b \b"; }
		} elsif(ord($key) == 21) {
			until($pass eq "") {
				chop($pass);
				unless(defined $hidden) { print "\b \b"; }
			}
		} else {
			unless(defined $hidden) { print "*"; }
			$pass .= $key;
		}
	}
	ReadMode("restore");
	debug(5, "Read password '$pass' for '$user' at $host'");
	return $pass;
}

#send a command (arg3) to a screen session (arg1) while on a window (arg2). This is not meant for sending input to whatever is running in that window
sub screencommand {
	my ($session, $window, $command) = @_;
	debug(2, "Doing command '$command' on window $window of screen session '$session'");
	unless(system("$screen -S $session -p $window -X $command") == 0) { error("Couldn't send '$command' to screen session '$session' when placing it on window $window"); }
}

#send input (arg3) to a window (arg2) of a screen session (arg1). If arg4 is defined a password is assumed and debug will only show the password if the debuglevel > 4
sub inputtoscreen {
	my ($session, $window, $input, $password) = @_;
	my $debugstring = "Sending ";
	my $withoutnewline = $input; chomp $withoutnewline;
	if(defined $password and $debuglevel < 5) { $debugstring.= "*HIDDEN PASSWORD*"; } else { $debugstring .= "'$withoutnewline'"; }
	if($input eq $withoutnewline) { $debugstring .= " (without a newline)"; } else { $debugstring .= " (followed by a newline)"; }
	debug(2, "$debugstring to window $window of screen session '$session'");
	unless(system("$screen -S $session -p $window -X stuff '$input'") == 0) { error("Couldn't send '$input' to window $window of screen session '$session'"); }
}

#create a detached screen with the sessionname in argument
sub createscreen {
	my $session = shift;
	foreach(split /\n/, debugbackticks("$screen -ls")) {
		if(/^\s*\d+\.$session\s+\(.+\)\s+\(.+\)\s*$/i) { error("Screen session '$session' already exists"); }
	}
	unless(debugsystem("$screen -d -m -S $session") == 0) { error("Can't create a detached screen"); }
}

#Complete info in $client and $server by examining the settings, error out if we are still missing things
sub examinesystem {
	if(defined $onserver) {
		if(not defined $server->{card}) { $server->{card} = searchinternetconnection()->{card}; }
	} else {
		if(not defined $server->{user}) { searchuser(); }
		if(not defined $server->{host}) { error("You didn't provide the server to connect to."); }
		if(not defined $client->{card}) { $client->{card} = searchinternetconnection()->{card}; }
		if(not defined $client->{gateway}) { $client->{gateway} = searchinternetconnection()->{gateway}; }
		if(not defined $client->{dnsservers}) { $client->{dnsservers} = searchdns($client->{card})->{servers}; }
		if(not defined $client->{domains}) { $client->{domains} = searchdns($client->{card})->{domains}; }
		## We'll search the dnsservers of the server later to skip a unneccessary connection
	}
}

#Find the dnsservers and domains on this system used by traffic on interface given as argument
sub searchdns {
	my $interface = shift;
	my @resolvelijnen = split /\n/, debugbackticks("$systemdresolve --no-pager -i $interface --status");
	while($#resolvelijnen > -1) {
		$_ = shift @resolvelijnen;
		if(/^\s*Link\s+\d+\s+\($interface\)\s*$/) {
			last;
		}
	}
	if($#resolvelijnen == -1) { error("No info found about dnsservers on interface $interface"); }
	my $dnsservers = {};	#hash because we don't want double values
	my @domains = ();
	for(my $i=0; $i < @resolvelijnen; $i++) {
		if($resolvelijnen[$i] =~ /^\s*Current DNS Server:\s+(\S+)\s*$/) { $dnsservers->{$1} = 1; }
		if($resolvelijnen[$i] =~ /^\s*DNS Servers:\s+(\S+)\s*$/) {
			$dnsservers->{$1} = 1;
			for(my $j=$i+1; $j < @resolvelijnen; $j++) {
				if($resolvelijnen[$j]=~/^\s*(\d+\.\d+\.\d+\.\d+)\s*$/) { $dnsservers->{$1} = 1; }
			}
		}
		if($resolvelijnen[$i] =~ /^\s*DNS Domain:\s+(\S+)\s*$/) {
			my $firstdomain = $1;
			unless($firstdomain eq "~.") { push(@domains, $firstdomain); }
			for(my $j=$i+1; $j < @resolvelijnen; $j++) {
				if($resolvelijnen[$j]=~/^\s{20}\s*(\S+\.\S+)\s*$/) { push(@domains, $1); }	#20 because a lot of spaces are needed
			}
		}
	}
	my @dnsservers = keys %$dnsservers;
	foreach(@dnsservers) {
		debug(2, "Found DNS-server '$_'");
	}
	foreach(@domains) {
		debug(2, "Found domain '$_'");
	}
	return { servers => \@dnsservers, domains => \@domains };
}

#Find the user to use to connect to the server
sub searchuser {
	if(defined $originaluser) {
		debug(3, "There was no user on the server defined, we 'll be using the one from the client: '$originaluser'");
		$server->{user} = $originaluser;
	} else {
		debug(3, "There was no user on the server defined, and the client didn't tell us which user he uses (so we can't copy it) so we'll have to use 'root'");
		my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid(0);
		$server->{user} = $name;
	}
}

#Search the card on the localsystem that is used to send traffic to the internet
sub searchinternetconnection {
	open(my $fh, "/proc/net/route") or error("Couldn't read '/proc/net/route' (the routingtable)");
	debug(3, "Begin reading /proc/net/route until we find the default route");
	debug(3, "This are the lines:");
	debug(3, "--- BEGIN CONTENTS '/proc/net/route' ---");
	while(<$fh>) {
		chomp $_;
		debug(3, $_);
		if(/^(\S+)\s+0{8}\s+([\dA-F]{8})\s+.*/) {
			my $card = $1;
			my $gateway = convertipformat($2);
			close $fh;
			debug(3, "--- STOPPED READING '/proc/net/route'  ---");
			debug(3, "Found gateway $gateway");
			debug(3, "Found card $card");
			return { card => $card, gateway => $gateway};
		}
	}
	close $fh;
	debug(3, "--- END OF '/proc/net/route' REACHED ---");
	error("Couldn't find gateway and card used for the internet connection (make sure you have a 0.0.0.0 route).");
}

sub convertipformat {
	my $oldip = shift;
	my $newip;
	if($oldip =~ /^[\dA-F]{8}$/) {	#From hex
		my @char=split(//,$oldip); my @number=();
		for(my $i=0; $i<4; $i++) { $number[$i] = hex($char[$i*2].$char[$i*2+1]);}
		$newip = "$number[3].$number[2].$number[1].$number[0]";
	} elsif($oldip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {	#To hex
		$newip = sprintf("%X%X%X%X", $4, $3, $2, $1);
	} else { error("'$oldip' is not a ip (in a valid format)"); }
	debug(3, "$oldip converted to $newip");
	return $newip;
}

#Find locations of all needed programs
sub findprograms {
	$ssh = searchlocation("ssh"); unless(defined $ssh) { error("'ssh' is not installed, on debian-based systems you can install it with 'apt-get install ssh'"); }
	$screen = searchlocation("screen"); unless(defined $screen) { error("'screen' is not installed, on debian-based systems you can install it with 'apt-get install screen'"); }
	$socat = searchlocation("socat"); unless(defined $socat) { error("'socat' is not installed, on debian-based systems you can install it with 'apt-get install socat'"); }
	$systemctl = searchlocation("systemctl"); unless(defined $systemctl) { error("systemd is not installed, on debian-based systems you can install it with 'apt-get install systemd'."); }
	if(defined $onserver) {
		$iptables = searchlocation("iptables"); unless(defined $iptables) { error("'iptables' is not installed, on debian-based systems you can install it with 'apt-get install iptables'"); }
		$journalctl = searchlocation("journalctl");
	} else {
		$scp = searchlocation("scp");
		$route = searchlocation("route"); unless(defined $route) { error("'route' is not installed, on debian-based systems you can install it with 'apt-get install net-tools'"); }
		$systemdresolve = searchlocation("systemd-resolve");
	}
}

#Check if necessary args are given and use them to change the settings
sub parseargs {
	my @argvcopy = @ARGV;
	if($#argvcopy == -1) { error("No arguments given. When running on the server you need (at least) --server-checkssh or --server. When running on the client you need (at least) the server to connect to"); }
	while($#argvcopy>=0) {
		$_ = shift @argvcopy;
		if(/^-p$/i or /^--port$/i) {
			if($#argvcopy < 0 or not $argvcopy[0] =~ /^\d+$/ or $argvcopy[0] == 0 or $argvcopy[0] > 65535) { error("No valid portnumber has been given to '-p' or '--port'"); }
			$server->{sshport} = shift @argvcopy;
		}
		elsif(/^-d$/i or /^--server-dns$/i or /^--client-dns$/i) {	#-d is short for--server-dns, -D is short for client-dns
			if($#argvcopy < 0) { error("No DNS-servers given to one of the dns-server options"); }
			my $dnsservers = shift @argvcopy;
			unless($dnsservers =~ /^[\d\.,]+$/) { error("Incorrect format for the DNS-servers, provide them as IP's seperated by commas. Example: 8.8.4.4,8.8.8.8"); }
			my @dnsservers = split(/,/, $dnsservers);
			if($_ eq "-d" or /^--server-dns$/i) { $server->{dnsservers} = \@dnsservers; } else { $client->{dnsservers} = \@dnsservers; }
		}
		elsif(/^-c$/i or /^--server-card$/i or /^--client-card$/i) {	#-c is short for--server-card, -C is short for client-card
			if($#argvcopy < 0) { error("No networkcard given to one of the networkcard options"); }
			my $card = shift @argvcopy;
			unless($card =~ /^\w+$/) { error("No valid networkcard has been given"); }
			if($_ eq "-c" or /^--server-card$/i) { $server->{card} = $card } else { $client->{card} = $card }
		}
		elsif(/^-g$/i) {
			if($#argvcopy < 0) { error("No gateway given to -g"); }
			$client->{gateway} = shift @argvcopy;
			unless($client->{gateway} =~ /^[\d\.]+$/) { error("Gateway should be provided as a IP address"); }
		}
		elsif(/^-o$/i or /^--original-user$/i) {
			if($#argvcopy < 0 or not $argvcopy[0] =~ /^\w+$/) { error("The original username has not been given"); }
			$originaluser = shift @argvcopy;
		}
		elsif(/^-n$/i or /^--subnets$/i) {
			if($#argvcopy < 0) { error("No subnets given"); }
			my $subnets = shift @argvcopy;
			unless($subnets =~ /^[\d\.\/,]+$/) { error("Incorrect format for the subnets, provide them as subnets seperated by commas. Example: 13.14.0.0/16,15.16.17.0/24"); }
			my @subnets = split(/,/, $subnets);
			$client->{subnets} = \@subnets;
		}
		elsif(/^-v$/ or /^--verbose$/i) { $debuglevel++; }
		elsif(/^--server$/i) { $onserver = 1; }	#the presence of the '--server' option determines if we are running on the server or on the client system
		elsif(/^--server-checkssh$/i) { $onserver = 1; $checkssh = 1; }	#the presence of the '--server-checkssh' option determines if we are still setting up the server locally
		elsif($#argvcopy == -1 and not defined $onserver) {
			if(/(.+)@(.+)/) { $server->{user} = $1; $server->{host} = $2; } else { $server->{host} = $_; }
		}
		else { error("'$_' is not a valid option"); }
	}
}

sub showsettings {
	if(defined $onserver) { debug(3, "Running as server"); } else { debug(3, "Running as client"); }
	if(defined $checkssh) { debug(3, "Running a sshcheck"); }
	debug(3, "Debuglevel: $debuglevel");
	debug(3, "server: " . Dumper($server));
	debug(3, "client: " . Dumper($client));
}

#exec() with debugmessage
sub debugexec {
	my $command = join(" ", @_);
	debug(2, "Now running '$command'. I won't return when this is finished.");
	exec(@_);
}

#system() with debugmessage
sub debugsystem {
	my $command = join(" ", @_);
	debug(2, "Now starting child '$command', i won't be using the output. I'll tell you the returncode when it's finished.");
	my $returncode = system(@_);
	debug(1, "'$command' was started and it finished with returncode '$returncode'");
	return $returncode;
}

#Same as `` but with debugmessage, if arg2 is defined it will crash unless the returncode equals this arg
sub debugbackticks {
	my $command = shift; my $wantedreturn = shift;
	debug(2, "Now starting child '$command' and i will be using it's output. I'll tell you the returncode when it's finished.");
	my $commandoutput = `$command`;
	my $returncode = $?;
	debug(1, "'$command' was started and it finished with returncode '$returncode'");
	if($debuglevel >= 3) {
		debug(3, "--- BEGIN OUTPUT '$command' ---");
		foreach(split(/\n/, $commandoutput)) {
			debug(3, "$_");
		}
		debug(3, "--- END OUTPUT '$command' ---");
	}
	if(defined $wantedreturn and $wantedreturn != $returncode) { error("The returncode $wantedreturn was expected from '$command', but the real one was $returncode");  }
	return $commandoutput;
}

#Restart the program as root if you are not root yet
sub runasroot {
	$sudo = searchlocation("sudo", "errordebian", "sudo");
	if($< == 0) {
		debug(1, "You are now running as root");	#... so that we can send a debugmessage if requested
	} else {
		debug(1, "You need to be root to run this script. I'll change the user for you.");	#... so that we can send a debugmessage if requested
		debugexec($sudo, "$RealBin/$RealScript", "-o", $name, @ARGV);
	}
}

#Prints errorstring passed as argument and exit with returncode 1
#If the string starts with a number, use this code instead and also mention the code in the output
sub error {
	my $error = shift;
	my $errorcode = 1; my $errorstring = $error;
	if($error=~/^(\d+)\s+(.*)/) { $errorcode = $1; $errorstring = $2 };
	say STDERR "ERROR $errorcode |$system|: $errorstring";
	exit $errorcode;
}

#use $PATH to find the location of program1, if arg2 contains "error", it will error instead of warn. If arg2 also contains debian it will mention that package arg3 needs to be installed when on debian-based systems
sub searchlocation {
	my $program = shift;
	foreach(split /:/, $ENV{PATH} ) {
		my $test = "$_/$program";
		if(-f $test and -x $test) {
			debug(2, "'$program' found at '$test'");
			return $test;
		}
	}
	debug(2, "'$program' not found in \$PATH (Which is '$ENV{PATH}')");
	$_ = shift(@_);
	if(defined $_ and /error/i) {
		my $errorstring = "Because we didn't find it in \$PATH, you'll probably still have to install '$program'";
		if(/debian/i){
			my $package=shift(@_);
			error("$errorstring, on debian-based systems you can do this with 'apt-get install $package'");
		} else {
			error($errorstring);
		}
	}
	return undef;
}

#Restarts the ssh-server if it's not running, shows on which port it's running which users are you might login as and quits the program
sub checksshserver {
	my $running = undef; my $outputmessage = undef;
	foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check if ssh runs
	if(defined $running) {
		debug(2, "ssh-server is running correctly.");
	} else {
		debug(1, "ssh-server is not running (correctly). I'll restart it.");
		debugsystem($systemctl, "start", "ssh"); sleep 5;	#restart it when it's not running correctly (and give it 5 seconds to start)
		foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check it again
		if(defined $running) {
			debug(2, "ssh-server started correctly.");
		} else {
			error("I can't start ssh correctly"); #die if it still fails
		}
	}
	foreach(split /\n/, debugbackticks("$journalctl -u ssh")) { if(/server\s+listening\s+on\s+\S+\s+port\s+(\d+)/i) { $outputmessage = "The sshserver is listening on tcp/$1"; } }	#check the port
	say "$outputmessage\nAvailable 'regular' users, make sure you can login as one of them:";
	open(my $fh, "/etc/passwd") or error("I can't read '/etc/passwd' this is needed to find available users.\nThe rest of the setup is done so if you know which username(s) you can use this isn't a error");
	while(<$fh>) {
		/^(.+?):.+?:(\d+).*/; if($1 ne "nobody" and $2 >= 1000) { say "- $1"; }
	}
	close $fh;
	say "- root (will probably not work, most sshservers block root-logins)";
	exit;
}

#Show a debugmessage if the debuglevel is high enough for this message
sub debug {
	my ($level, $message) = @_;
	if($debuglevel >= $level) { say STDERR "DEBUG $level |$system|: $message"; }
}
