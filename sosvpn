#!/usr/bin/perl
use v5.16; use warnings; use strict;
use FindBin qw($Bin $RealBin $RealScript); use lib "$Bin/../lib";
use Data::Dumper; #For debugging


### Settings according to the example in README.md ###
#( You don't want use these but you can leave them here for documentational purposes, they are overwritten in the next step)
my $server = {
	user	=> "someuser",
	ip	=> "1.2.3.4",
	card	=> "eths",
	sshport	=> 22789,
	dns	=> [ "5.6.7.8", "9.10.11.12" ]
};
my $client = {
	ip	=> "13.14.15.16",
	card	=> "ethc",
	gateway	=> "13.14.0.254",
	subnets	=> [ "13.14.0.0/16", "15.16.17.0/24" ],
	dns	=> [ "15.16.17.1", "15.16.17.2"]
};


### Default settings ###
$server = {}; $client = {};	#cleanup example settings
$server->{sshport} = 22;	#default ssh port
$server->{dns} = [ "8.8.4.4", "8.8.8.8" ];	#google dnsservers, if the isp of the server blocks these, use the ones of your isp

#default settings of other things
my $onserver = undef;	#defined when running on the server
my $serversetup = undef;	#defined if we are still setting up the server
my $debuglevel = 0;


### Main part of the program
runasroot();
parseargs();
#Check if all software is installed and search the locations
my $ssh = searchlocation("ssh"); unless(defined $ssh) { error("'ssh' is not installed, on debian-based systems you can install it with 'apt-get install ssh'"); }
my $screen = searchlocation("screen"); unless(defined $screen) { error("'screen' is not installed, on debian-based systems you can install it with 'apt-get install screen'"); }
my $socat = searchlocation("socat"); unless(defined $socat) { error("'socat' is not installed, on debian-based systems you can install it with 'apt-get install socat'"); }
my $iptables; my $systemctl; my $journalctl; my $route;
if(defined $onserver) {
	$iptables = searchlocation("iptables"); unless(defined $iptables) { error("'iptables' is not installed, on debian-based systems you can install it with 'apt-get install iptables'"); }
	$systemctl = searchlocation("systemctl"); unless(defined $systemctl) { error("systemd is not installed, on debian-based systems you can install it with 'apt-get install systemd'."); }
	$journalctl = searchlocation("journalctl");
} else {
	$route = searchlocation("route"); unless(defined $route) { error("'route' is not installed, on debian-based systems you can install it with 'apt-get install net-tools'"); }
}
if(defined $serversetup) { checksshserver(); }	#Restarts the server if it's not running, shows some connection possibilities and quits the program


### Subroutine definitions

#Check if necessary args are given and use them to change the settings
sub parseargs {
	my $finalargument = undef;
	if($#ARGV == -1) { error("No arguments given. When running on the server you need (at least) --serversetup or --server. When running on the client you need (at least) the server to connect to"); }
	while($#ARGV>=0) {
		$_ = shift @ARGV;
		if(/^-p$/i or /^--port$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^\d+$/ or $ARGV[0] == 0 or $ARGV[0] > 65535) { error("No valid portnumber has been given to '-p'"); }
			$server->{sshport} = shift @ARGV;
		}
		elsif(/^-v$/i or /^--verbose$/) { $debuglevel++; }
		elsif(/^--server$/i) { $onserver = 1; }	#the presence of the '--server' option determines if we are running on the server or on the client system
		elsif(/^--serversetup$/i) { $onserver = 1; $serversetup = 1; }	#the presence of the '--serversetup' option determines if we are still setting up the server locally
		elsif($#ARGV > -1) { error("'$_' is not a valid option"); }
		else { $finalargument = $_ }
	}
	if(defined $onserver) {
		#nothing yet...
	} else {
		if(not defined $finalargument) { error("No host is given to connect to"); }
		if($finalargument =~ /(.+)@(.+)/) { $server->{user} = $1; $server->{ip} = $2; } else { $server->{ip} = $finalargument; }
	}
	if(defined $onserver) { debug(3, "Running as server"); } else { debug(3, "Running as client"); }
	if(defined $serversetup) { debug(3, "Running as a serversetup"); }
	debug(3, "Debuglevel: $debuglevel");
	debug(3, "server: " . Dumper($server));
	debug(3, "client: " . Dumper($client));
	if($debuglevel > 3) { exit; }
}

#exec() with debugmessage
sub debugexec {
	my $command = join(" ", @_);
	debug(2, "Now running '$command'. I won't return when this is finished.");
	exec(@_);
}

#system() with debugmessage
sub debugsystem {
	my $command = join(" ", @_);
	debug(2, "Now starting child '$command', i won't be using the output. I'll tell you the returncode when it's finished.");
	my $returncode = system(@_);
	debug(1, "'$command' was started and it finished with returncode '$returncode'");
}

#Same as `` but with debugmessage
sub debugbackticks {
	my $command = shift;
	debug(2, "Now starting child '$command' and i will be using it's output. I'll tell you the returncode when it's finished.");
	my $commandoutput = `$command`;
	debug(1, "'$command' was started and it finished with returncode '$?'");
	if($debuglevel >= 3) {
		debug(3, "This was it's output:");
		debug(3, "--- BEGIN OUTPUT '$command' ---");
		foreach(split(/\n/, $commandoutput)) {
			debug(3, "$_");
		}
		debug(3, "--- END OUTPUT '$command' ---");
	}
	return $commandoutput;
}

#Restart the program as root if you are not root yet
sub runasroot {
	unless($< == 0) {
		foreach(@ARGV) { if(/^-v$/i or /^--verbose$/) { $debuglevel++; } }	#this sub runs before checking the args (or we lose them and can't pass them to sudo) so we have to check for a -v here... 
		debug(1, "You need to be root to run this script. I'll change the user for you.");	#... so that we can send a debugmessage if requested
		my $sudo = searchlocation("sudo");
		if(not defined $sudo) { error("'sudo' is not available. you'll have to find another way to become root and run this script."); }
		debugexec($sudo, "$RealBin/$RealScript", @ARGV);
	}
}

#Prints errorstring passed as argument and exit with returncode 1
#If the string starts with a number, use this code instead and also mention the code in the output
sub error {
	my $error = shift;
	my $errorcode = 1; my $errorstring = $error;
	if($error=~/^(\d+)\s+(.*)/) { $errorcode = $1; $errorstring = $2 };
	print STDERR "error";
	unless($errorcode == 1) { print STDERR " (code $errorcode)"; }
	print STDERR ": $errorstring\n";
	exit $errorcode;
}

#use $PATH to find the location of a program passed as argument
sub searchlocation {
	my $program = shift;
	foreach(split /:/, $ENV{PATH} ) {
		my $test = "$_/$program";
		if(-f $test and -x $test) {
			debug(2, "'$program' found at '$test'");
			return $test;
		}
	}
	return undef;
}

#Restarts the ssh-server if it's not running, shows on which port it's running which users are you might login as and quits the program
sub checksshserver {
	my $running = undef; my $outputmessage = undef;
	foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check if ssh runs
	if(defined $running) {
		debug(2, "ssh-server is running correctly.");
	} else {
		debug(1, "ssh-server is not running (correctly). I'll restart it.");
		debugsystem($systemctl, "start", "ssh"); sleep 5;	#restart it when it's not running correctly (and give it 5 seconds to start)
		foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check it again
		if(defined $running) {
			debug(2, "ssh-server started correctly.");
		} else {
			error("I Can't start ssh correctly"); #die if it still fails
		}
	}
	foreach(split /\n/, debugbackticks("$journalctl -u ssh")) { if(/server\s+listening\s+on\s+\S+\s+port\s+(\d+)/i) { $outputmessage = "The sshserver is listening on tcp/$1"; } }	#check the port
	say "$outputmessage\nAvailable 'regular' users, make sure you can login as one of them:";
	open(my $fh, "/etc/passwd") or error("I can't read '/etc/passwd' this is needed to find available users.\nThe rest of the setup is done so if you know which username(s) you can use this isn't a problem");
	while(<$fh>) {
		/^(.+?):.+?:(\d+).*/; if($1 ne "nobody" and $2 >= 1000) { say "- $1"; }
	}
	close $fh;
	say "- root (will probably not work, most sshservers block root-logins)";
	exit;
}

#Show a debugmessage if the debuglevel is high enough for this message
sub debug {
	my ($level, $message) = @_;
	if($debuglevel >= $level) { say STDERR "DEBUG ($level): $message"; }
}
