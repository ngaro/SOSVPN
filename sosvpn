#!/usr/bin/perl
use v5.16; use warnings; use strict;
use FindBin qw($Bin $RealBin $RealScript); use lib "$Bin/../lib";
use Term::ReadKey;
use Data::Dumper; #For debugging


### Settings according to the example in README.md ###
#( You don't want use these but you can leave them here for documentational purposes, they are overwritten in the next step)
my $server = {
	user	=> "someuser",
	host	=> "1.2.3.4",
	card	=> "eths",
	sshport	=> 22789,
	dnsservers	=> [ "5.6.7.8", "9.10.11.12" ]
};
my $client = {
	card	=> "ethc",
	gateway	=> "13.14.0.254",
	subnets	=> [ "13.14.0.0/16", "15.16.17.0/24" ],
	dnsservers	=> [ "15.16.17.1", "15.16.17.2"],
	domains	=> [ "mylocal.net" ]
};

#Constants
my $clientportforward = 22002;
my $serverportforward = 22001;
my $clientsession = "sosvpn";
my $serverscriptlocation = "/tmp/sosvpn";
my $clientlogfile = "/tmp/logfile";

#Settings that can only be overwritten in code
my $system = "Unknown (unknown)";


### Default settings ###
$server = {}; $client = {};	#cleanup example settings
$server->{sshport} = 22;	#default ssh port
$server->{dnsservers} = [ "8.8.4.4", "8.8.8.8" ];	#google dnsservers, if the isp of the server blocks these, use the ones of your isp

#default settings of other things
my $onserver = undef;	#defined when running on the server
my $checkssh = undef;	#defined if we are checking ssh the server
my $debuglevel = 0;
my $originaluser = undef;


### Main part of the program
setsystemstring();
runasroot();
parseargs();
my ($ssh, $screen, $socat, $iptables, $systemctl, $journalctl, $route, $systemdresolve, $sudo, $scp); findprograms();
examinesystem();
showsettings();
if(defined $checkssh) { checksshserver(); }	#Restarts the sshserver if it's not running, shows some connection possibilities and quits the program
if(defined $onserver) {
	servercode();
	debug(1, "Server finished");
} else {
	clientcode();
	debug(1, "Client finished");
}
if($debuglevel > 3) { error("$debuglevel Quiting as requested because of high debuglevel..."); }


### Subroutine definitions

sub setsystemstring {
	if(defined $onserver) { $system =~ s/Unknown/Server/; } else { $system =~ s/Unknown/Client/; }
	my $hostname = searchlocation("hostname");
	if(defined $hostname) {
		my $thishost = debugbackticks($hostname);
		chomp $thishost;
		$system =~ s/unknown/$thishost/;
	} else {
		debug(2, "'hostname' is not installed");
	}
}

#Everything the code does when running as a server
sub servercode {
	debug(0,"TODO");
	exit;
}

#Run a screen in the background and control it for the clientcode
sub clientcode {
	debugsystem("$scp $RealBin/$RealScript $server->{user}\@$server->{host}:$serverscriptlocation");
	createscreen($clientsession);
	screencommand($clientsession, 0, "logfile $clientlogfile.0");
	screencommand($clientsession, 0, "log on");
	my $commandinssh = "$serverscriptlocation --server";
	if(defined $server->{card}) { $commandinssh .= " --server-card $server->{card}"; }
	inputtoscreen($clientsession, 0, "$sudo -u $originaluser $ssh -t -L $clientportforward:127.0.0.1:$serverportforward -p $server->{sshport} $server->{user}\@$server->{host} $commandinssh\n");
	my $pass = readpass($server->{user}, $server->{host});
	OUTERLOOP: while(1) {
		open(my $fh, "$clientlogfile.0");
		while(<$fh>) {
			if(/^\s*\[sudo\]/) { close $fh; last OUTERLOOP; }
		}
		close $fh;
	}
	inputtoscreen($clientsession, 0, "$pass\n", "password");
	if($debuglevel < 4) {
		screencommand($clientsession, 0, "log off");
		if($debuglevel < 3) { unlink("$clientlogfile.0"); }
	}
}

#return the pass read from STDIN for user arg1 on host arg2, do not show asterisks if arg3 is defined
sub readpass {
	my ($user, $host, $hidden) = @_;
	printf("Password for $user at $host: ");
	my $pass = "";
	ReadMode("raw");
	while(1) {
		my $key = ReadKey;
		if(ord($key) == 10) {
			print "\n";
			last;
		} elsif(ord($key) == 8 || ord($key) == 127) {
			if($pass eq "") { next; }
			chop($pass);
			unless(defined $hidden) { print "\b \b"; }
		} elsif(ord($key) == 21) {
			until($pass eq "") {
				chop($pass);
				unless(defined $hidden) { print "\b \b"; }
			}
		} else {
			unless(defined $hidden) { print "*"; }
			$pass .= $key;
		}
	}
	ReadMode("restore");
	debug(5, "Read password '$pass' for '$user' at $host'");
	return $pass;
}

#send a command (arg3) to a screen session (arg1) while on a window (arg2). This is not meant for sending input to whatever is running in that window
sub screencommand {
	my ($session, $window, $command) = @_;
	debug(2, "Doing command '$command' on window $window of screen session '$session'");
	unless(system("$screen -S $session -p $window -X $command") == 0) { error("Couldn't send '$command' to screen session '$session' when placing it on window $window"); }
}

#send input (arg3) to a window (arg2) of a screen session (arg1). If arg4 is defined a password is assumed and debug will only show the password if the debuglevel > 4
sub inputtoscreen {
	my ($session, $window, $input, $password) = @_;
	my $debugstring = "Sending ";
	my $withoutnewline = $input; chomp $withoutnewline;
	if(defined $password and $debuglevel < 5) { $debugstring.= "*HIDDEN PASSWORD*"; } else { $debugstring .= "'$withoutnewline'"; }
	if($input eq $withoutnewline) { $debugstring .= " (without a newline)"; } else { $debugstring .= " (followed by a newline)"; }
	debug(2, "$debugstring to window $window of screen session '$session'");
	unless(system("$screen -S $session -p $window -X stuff '$input'") == 0) { error("Couldn't send '$input' to window $window of screen session '$session'"); }
}

#create a detached screen with the sessionname in argument
sub createscreen {
	my $session = shift;
	foreach(split /\n/, debugbackticks("$screen -ls")) {
		if(/^\s*\d+\.$session\s+\(.+\)\s+\(.+\)\s*$/i) { error("Screen session '$session' already exists"); }
	}
	unless(debugsystem("$screen -d -m -S $session") == 0) { error("Can't create a detached screen"); }
}

#Complete info in $client and $server by examining the settings, error out if we are still missing things
sub examinesystem {
	if(defined $onserver) {
		if(not defined $server->{card}) { $server->{card} = searchinternetconnection()->{card}; }
	} else {
		if(not defined $server->{user}) { searchuser(); }
		if(not defined $server->{host}) { error("You didn't provide the server to connect to."); }
		if(not defined $client->{card}) { $client->{card} = searchinternetconnection()->{card}; }
		if(not defined $client->{gateway}) { $client->{gateway} = searchinternetconnection()->{gateway}; }
		if(not defined $client->{dnsservers}) { $client->{dnsservers} = searchdns($client->{card})->{servers}; }
		if(not defined $client->{domains}) { $client->{domains} = searchdns($client->{card})->{domains}; }
		## We'll search the dnsservers of the server later to skip a unneccessary connection
	}
}

#Find the dnsservers and domains on this system used by traffic on interface given as argument
sub searchdns {
	my $interface = shift;
	my @resolvelijnen = split /\n/, debugbackticks("$systemdresolve --no-pager -i $interface --status");
	while($#resolvelijnen > -1) {
		$_ = shift @resolvelijnen;
		if(/^\s*Link\s+\d+\s+\($interface\)\s*$/) {
			last;
		}
	}
	if($#resolvelijnen == -1) { error("No info found about dnsservers on interface $interface"); }
	my $dnsservers = {};	#hash because we don't want double values
	my @domains = ();
	for(my $i=0; $i < @resolvelijnen; $i++) {
		if($resolvelijnen[$i] =~ /^\s*Current DNS Server:\s+(\S+)\s*$/) { $dnsservers->{$1} = 1; }
		if($resolvelijnen[$i] =~ /^\s*DNS Servers:\s+(\S+)\s*$/) {
			$dnsservers->{$1} = 1;
			for(my $j=$i+1; $j < @resolvelijnen; $j++) {
				if($resolvelijnen[$j]=~/^\s*(\d+\.\d+\.\d+\.\d+)\s*$/) { $dnsservers->{$1} = 1; }
			}
		}
		if($resolvelijnen[$i] =~ /^\s*DNS Domain:\s+(\S+)\s*$/) {
			my $firstdomain = $1;
			unless($firstdomain eq "~.") { push(@domains, $firstdomain); }
			for(my $j=$i+1; $j < @resolvelijnen; $j++) {
				if($resolvelijnen[$j]=~/^\s{20}\s*(\S+\.\S+)\s*$/) { push(@domains, $1); }	#20 because a lot of spaces are needed
			}
		}
	}
	my @dnsservers = keys %$dnsservers;
	foreach(@dnsservers) {
		debug(2, "Found DNS-server '$_'");
	}
	foreach(@domains) {
		debug(2, "Found domain '$_'");
	}
	return { servers => \@dnsservers, domains => \@domains };
}

#Find the user to use to connect to the server
sub searchuser {
	if(defined $originaluser) {
		debug(3, "There was no user on the server defined, we 'll be using the one from the client: '$originaluser'");
		$server->{user} = $originaluser;
	} else {
		debug(3, "There was no user on the server defined, and the client didn't tell us which user he uses (so we can't copy it) so we'll have to use 'root'");
		$server->{user} = 'root';
	}
}

#Search the card on the localsystem that is used to send traffic to the internet
sub searchinternetconnection {
	open(my $fh, "/proc/net/route") or error("Couldn't read '/proc/net/route' (the routingtable)");
	debug(3, "Begin reading /proc/net/route until we find the default route");
	debug(3, "This are the lines:");
	debug(3, "--- BEGIN CONTENTS '/proc/net/route' ---");
	while(<$fh>) {
		chomp $_;
		debug(3, $_);
		if(/^(\S+)\s+0{8}\s+([\dA-F]{8})\s+.*/) {
			my $card = $1;
			my $gateway = convertipformat($2);
			close $fh;
			debug(3, "--- STOPPED READING '/proc/net/route'  ---");
			debug(3, "Found gateway $gateway");
			debug(3, "Found card $card");
			return { card => $card, gateway => $gateway};
		}
	}
	close $fh;
	debug(3, "--- END OF '/proc/net/route' REACHED ---");
	error("Couldn't find gateway and card used for the internet connection (make sure you have a 0.0.0.0 route).");
}

sub convertipformat {
	my $oldip = shift;
	my $newip;
	if($oldip =~ /^[\dA-F]{8}$/) {	#From hex
		my @char=split(//,$oldip); my @number=();
		for(my $i=0; $i<4; $i++) { $number[$i] = hex($char[$i*2].$char[$i*2+1]);}
		$newip = "$number[3].$number[2].$number[1].$number[0]";
	} elsif($oldip =~ /^(\d+)\.(\d+)\.(\d+)\.(\d+)$/) {	#To hex
		$newip = sprintf("%X%X%X%X", $4, $3, $2, $1);
	} else { error("'$oldip' is not a ip (in a valid format)"); }
	debug(3, "$oldip converted to $newip");
	return $newip;
}

#Find locations of all needed programs
sub findprograms {
	$ssh = searchlocation("ssh"); unless(defined $ssh) { error("'ssh' is not installed, on debian-based systems you can install it with 'apt-get install ssh'"); }
	$screen = searchlocation("screen"); unless(defined $screen) { error("'screen' is not installed, on debian-based systems you can install it with 'apt-get install screen'"); }
	$socat = searchlocation("socat"); unless(defined $socat) { error("'socat' is not installed, on debian-based systems you can install it with 'apt-get install socat'"); }
	$systemctl = searchlocation("systemctl"); unless(defined $systemctl) { error("systemd is not installed, on debian-based systems you can install it with 'apt-get install systemd'."); }
	if(defined $onserver) {
		$iptables = searchlocation("iptables"); unless(defined $iptables) { error("'iptables' is not installed, on debian-based systems you can install it with 'apt-get install iptables'"); }
		$journalctl = searchlocation("journalctl");
	} else {
		$scp = searchlocation("scp");
		$route = searchlocation("route"); unless(defined $route) { error("'route' is not installed, on debian-based systems you can install it with 'apt-get install net-tools'"); }
		$systemdresolve = searchlocation("systemd-resolve");
	}
}

#Check if necessary args are given and use them to change the settings
sub parseargs {
	if($#ARGV == -1) { error("No arguments given. When running on the server you need (at least) --server-checkssh or --server. When running on the client you need (at least) the server to connect to"); }
	while($#ARGV>=0) {
		$_ = shift @ARGV;
		if(/^-p$/i or /^--port$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^\d+$/ or $ARGV[0] == 0 or $ARGV[0] > 65535) { error("No valid portnumber has been given to '-p' or '--port'"); }
			$server->{sshport} = shift @ARGV;
		}
		elsif(/^-d$/i or /^--server-dns$/i or /^--client-dns$/) {	#-d is short for--server-dns, -D is short for client-dns
			if($#ARGV < 0) { error("No DNS-servers given to one of the dns-server options"); }
			my $dnsservers = shift @ARGV;
			unless($dnsservers =~ /^[\d\.,]+$/) { error("Incorrect format for the DNS-servers, provide them as IP's seperated by commas. Example: 8.8.4.4,8.8.8.8"); }
			my @dnsservers = split(/,/, $dnsservers);
			if($_ eq "-d" or /^--server-dns$/) { $server->{dnsservers} = \@dnsservers; } else { $client->{dnsservers} = \@dnsservers; }
		}
		elsif(/^-c$/i or /^--server-card$/i or /^--client-card$/) {	#-c is short for--server-card, -C is short for client-card
			if($#ARGV < 0) { error("No networkcard given to one of the networkcard options"); }
			my $card = shift @ARGV;
			unless($card =~ /^\w+$/) { error("No valid networkcard has been given"); }
			if($_ eq "-c" or /^--server-card$/) { $server->{card} = $card } else { $client->{card} = $card }
		}
		elsif(/^-g$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^[\d\.]+$/) { error("No gateway has been given"); }
			$client->{gateway} = shift @ARGV;
		}
		elsif(/^-o$/i or /^--original-user$/i) {
			if($#ARGV < 0 or not $ARGV[0] =~ /^\w+$/) { error("The original username has not been given"); }
			$originaluser = shift @ARGV;
		}
		elsif(/^-n$/i or /^--subnets$/i) {
			if($#ARGV < 0) { error("No subnets given"); }
			my $subnets = shift @ARGV;
			unless($subnets =~ /^[\d\.\/,]+$/) { error("Incorrect format for the subnets, provide them as subnets seperated by commas. Example: 13.14.0.0/16,15.16.17.0/24"); }
			my @subnets = split(/,/, $subnets);
			$client->{subnets} = \@subnets;
		}
		elsif(/^-v$/i or /^--verbose$/) { $debuglevel++; }
		elsif(/^--server$/i) { $onserver = 1; }	#the presence of the '--server' option determines if we are running on the server or on the client system
		elsif(/^--server-checkssh$/i) { $onserver = 1; $checkssh = 1; }	#the presence of the '--server-checkssh' option determines if we are still setting up the server locally
		elsif($#ARGV == -1 and not defined $onserver) {
			if(/(.+)@(.+)/) { $server->{user} = $1; $server->{host} = $2; } else { $server->{host} = $_; }
		}
		else { error("'$_' is not a valid option"); }
	}
}

sub showsettings {
	if(defined $onserver) { debug(3, "Running as server"); } else { debug(3, "Running as client"); }
	if(defined $checkssh) { debug(3, "Running a sshcheck"); }
	debug(3, "Debuglevel: $debuglevel");
	debug(3, "server: " . Dumper($server));
	debug(3, "client: " . Dumper($client));
}

#exec() with debugmessage
sub debugexec {
	my $command = join(" ", @_);
	debug(2, "Now running '$command'. I won't return when this is finished.");
	exec(@_);
}

#system() with debugmessage
sub debugsystem {
	my $command = join(" ", @_);
	debug(2, "Now starting child '$command', i won't be using the output. I'll tell you the returncode when it's finished.");
	my $returncode = system(@_);
	debug(1, "'$command' was started and it finished with returncode '$returncode'");
	return $returncode;
}

#Same as `` but with debugmessage
sub debugbackticks {
	my $command = shift;
	debug(2, "Now starting child '$command' and i will be using it's output. I'll tell you the returncode when it's finished.");
	my $commandoutput = `$command`;
	debug(1, "'$command' was started and it finished with returncode '$?'");
	if($debuglevel >= 3) {
		debug(3, "This was it's output:");
		debug(3, "--- BEGIN OUTPUT '$command' ---");
		foreach(split(/\n/, $commandoutput)) {
			debug(3, "$_");
		}
		debug(3, "--- END OUTPUT '$command' ---");
	}
	return $commandoutput;
}

#Restart the program as root if you are not root yet
sub runasroot {
	$sudo = searchlocation("sudo");
	if(not defined $sudo) { error("'sudo' is not available. you'll have to find another way to become root and run this script."); }
	unless($< == 0) {
		foreach(@ARGV) { if(/^-v$/i or /^--verbose$/) { $debuglevel++; } }	#this sub runs before checking the args (or we lose them and can't pass them to sudo) so we have to check for a -v here... 
		debug(1, "You need to be root to run this script. I'll change the user for you.");	#... so that we can send a debugmessage if requested
		my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwuid($<);
		debugexec($sudo, "$RealBin/$RealScript", "-o", $name, @ARGV);
	}
}

#Prints errorstring passed as argument and exit with returncode 1
#If the string starts with a number, use this code instead and also mention the code in the output
sub error {
	my $error = shift;
	my $errorcode = 1; my $errorstring = $error;
	if($error=~/^(\d+)\s+(.*)/) { $errorcode = $1; $errorstring = $2 };
	print STDERR "error";
	unless($errorcode == 1) { print STDERR " (code $errorcode)"; }
	print STDERR ": $errorstring\n";
	exit $errorcode;
}

#use $PATH to find the location of a program passed as argument
sub searchlocation {
	my $program = shift;
	foreach(split /:/, $ENV{PATH} ) {
		my $test = "$_/$program";
		if(-f $test and -x $test) {
			debug(2, "'$program' found at '$test'");
			return $test;
		}
	}
	return undef;
}

#Restarts the ssh-server if it's not running, shows on which port it's running which users are you might login as and quits the program
sub checksshserver {
	my $running = undef; my $outputmessage = undef;
	foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check if ssh runs
	if(defined $running) {
		debug(2, "ssh-server is running correctly.");
	} else {
		debug(1, "ssh-server is not running (correctly). I'll restart it.");
		debugsystem($systemctl, "start", "ssh"); sleep 5;	#restart it when it's not running correctly (and give it 5 seconds to start)
		foreach(split /\n/, debugbackticks("$systemctl status ssh")) { if(/^\s*active:\s*active\s*\(\s*running\s*\)/i) { $running = 1; } }	#check it again
		if(defined $running) {
			debug(2, "ssh-server started correctly.");
		} else {
			error("I can't start ssh correctly"); #die if it still fails
		}
	}
	foreach(split /\n/, debugbackticks("$journalctl -u ssh")) { if(/server\s+listening\s+on\s+\S+\s+port\s+(\d+)/i) { $outputmessage = "The sshserver is listening on tcp/$1"; } }	#check the port
	say "$outputmessage\nAvailable 'regular' users, make sure you can login as one of them:";
	open(my $fh, "/etc/passwd") or error("I can't read '/etc/passwd' this is needed to find available users.\nThe rest of the setup is done so if you know which username(s) you can use this isn't a error");
	while(<$fh>) {
		/^(.+?):.+?:(\d+).*/; if($1 ne "nobody" and $2 >= 1000) { say "- $1"; }
	}
	close $fh;
	say "- root (will probably not work, most sshservers block root-logins)";
	exit;
}

#Show a debugmessage if the debuglevel is high enough for this message
sub debug {
	my ($level, $message) = @_;
	if($debuglevel >= $level) { say STDERR "DEBUG $level |$system|: $message"; }
}
